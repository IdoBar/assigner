---
title: "Comparison of Fst computations using : `assigner`, `hierfstat`, `strataG`, `diveRsity`, `GENODIVE`."
author: "Thierry Gosselin"
date: "`r Sys.Date()`"
output: html_notebook
# output: 
# pdf_document:
vignette: >
  %\VignetteIndexEntry{"Comparison of Fst computations using : `assigner`, `hierfstat`, `strataG`, `diveRsity`, `GENODIVE`."}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---
  
  
# Prepare your R session
  
Copy/paste the chunck below
  
```{r Prepare your R session}
rm(list = ls())
if (!require("pacman")) install.packages("pacman")
library("pacman")
pacman::p_load(devtools, tibble, reshape2, ggplot2, stringr, stringi, plyr, dplyr, tidyr, readr, purrr, data.table, ape, parallel, lazyeval, randomForestSRC, adegenet, hierfstat, strataG, diveRsity)
# repeat to load libraries that were just installed 
pacman::p_load(devtools, tibble, reshape2, ggplot2, stringr, stringi, plyr, dplyr, tidyr, readr, purrr, data.table, ape, parallel, lazyeval, randomForestSRC, adegenet, hierfstat, strataG, diveRsity)
devtools::install_github("thierrygosselin/stackr", build_vignettes = TRUE)
library("stackr")
devtools::install_github("thierrygosselin/assigner", build_vignettes = TRUE)
library("assigner")
```

Put this Rmd notebook in the same directory as the data or use `setwd("/YOUR/NEW/PATH/HERE/")`, to change it. 

# Why trust assigner ?

Let's compare `assigner's` Fst calculations (using Weir and Cockerham, 1984), with alternatives.

* use a genomic dataset with thousands of markers so that alternative software stand out
* use `stackr::genomic_converter` to generate the necessary output files:
* the argument `output` allows to use multiple output format at the same time
* `genepop` file for Patrick Meirmans's `GENODIVE` and Kevin Keenan's `diveRsity` package
* `hierfstat` object and file for Jérome Goudet's `hierfstat` package
* `gtypes` object for Eric Archer's `strataG` package
* `genind` objet for Thibault Jombert's `adegenet` package
* the funtion will produce a tidy dataset that will be use as input for the fst computation in `assigner`.


The unfiltered vcf was provided by Gregory Owens

Owens GL, Baute GJ, Rieseberg LH. Revisiting a classic case of introgression: hybridization and gene flow in Californian sunflowers. Abbott RJ, Barton NH, Good JM, editors. Molecular Ecology. 2016;25: 2630–2643. doi:10.1111/mec.13569

```{r genomic converter}
sunflower <- stackr::genomic_converter(
  data = "sunflower.vcf", 
  strata = "sunflower.strata.tsv", 
  output = c("genepop", "gtypes", "hierfstat", "genind"),
  filename = "sunflower" # this is optional, stackr can name file based on date/time
)
```

**Number of markers: from 34258 -> 15974 markers, howcome ?**

The function will automatically prune the markers to keep only the markers 
in common between populations, the default is `common.markers = TRUE`:

* for more info, see function documentation by typing `?stackr::genomic_converter`
* another vignette show the strategy behind using `common.markers = FALSE`. More on this later.

The `sunflower` object created is a list with several objects inside:
```{r list the objects}
names(sunflower)
```

The object contains the a *tidy dataset*, a *gtypes*, a *genind* and a *hierfstat* objects, without imputation.
The *genepop* and *hierfstat* files are in the working directory.

#strataG

* use the `gtypes` object: `sunflower$gtypes.no.imputation`
* results of the analysis are stored in `$pairwise$result`
* use `dplyr::select` to select and rename column headers we need.
* after the command below, take a break (~ 40 min on my MBP)

```{r run strataG}
system.time(
  stratag.fst <- strataG::popStructTest(g = sunflower$gtypes.no.imputation, stats = "fst", type = "pairwise", quietly = TRUE, max.cores = 7, nrep = 0, keep.null = FALSE, write.output = FALSE)$pairwise$result %>% 
    dplyr::select(POP1 = strata.1, POP2 = strata.2, STRATAG = Fst)
)
```

```{r strataG results}
stratag.fst
```

# HIERFSTAT

* Change the name of the `.dat` file in your working directory if you didn't use the `filename` argument like I did
* After running the code below, get some coffee because it will take some time... (~ 45 min on my MBP)

```{r run hierfstat}
system.time(
  hierfstat.pairwise.fst <- hierfstat::pairwise.WCfst(
    dat = hierfstat::read.fstat.data(fname = "sunflower.dat"), 
    diploid = TRUE
  )
)
```

Work on the matrix:

* we need the pop.id string
* give the matrix rownames and colnames
* fill the diagonal with 0
* transform the matrix into a more useful pairwise df with appropriate column names

```{r hierfstat results modification}
pop.list <- as.character(unique(sunflower$tidy.data$POP_ID)) # pop.id string:
colnames(hierfstat.pairwise.fst) <- rownames(hierfstat.pairwise.fst) <- pop.list # matrix rownames and colnames
hierfstat.pairwise.fst <- dplyr::coalesce(hierfstat.pairwise.fst, 0) # diagonal with 0

# melt in a 3 columns df
hierfstat.fst <- stats::na.omit(
  reshape2::melt(
    data = hierfstat.pairwise.fst, 
    varnames = c("POP1", "POP2"),
    value.name = "HIERFSTAT",
    na.rm = TRUE)[reshape2::melt(upper.tri(hierfstat.pairwise.fst, diag = FALSE))$value,]
) %>% 
  tibble::as_data_frame() %>% 
  dplyr::mutate_at(.cols = c("POP1", "POP2"), .funs = as.character) %>% 
  dplyr::arrange(POP1, POP2)
hierfstat.fst
```

# diveRsity

* `package diveRsity` requires the `genepop` file created above
* part of the codes inside the package are optimized with C++!
* no need for a coffee (~ 70 sec on my MBP)


```{r run diveRsity}
system.time(
  diversity.fst.matrix <- diveRsity::diffCalc(
    infile = "sunflower.gen", 
    outfile = "sunflower_diversity", 
    fst = TRUE,
    pairwise = TRUE,
    para = TRUE
  )
)
```

**Wow! this is very fast**

The results need more work to be useful:

* we need the pop.id string, because population naming from genepop file sucks.
* isolate the divesity matrix object with pairwise info
* give the matrix rownames and colnames
* fill the diagonal and upper matrix with 0
* transform the lower matrix into a more useful pairwise df with appropriate column names

```{r diveRsity results manipulation}
pop.list <- as.character(unique(sunflower$tidy.data$POP_ID)) # pop.id string:
diversity.fst.matrix <- diversity.fst.matrix$pairwise$Fst # isolate the divesity object with pairwise info
colnames(diversity.fst.matrix) <- rownames(diversity.fst.matrix) <- pop.list # matrix rownames and colnames
diversity.fst.matrix <- dplyr::coalesce(diversity.fst.matrix, 0) # diagonal with 0

# melt in a 3 columns df
diversity.fst <- stats::na.omit(
  reshape2::melt(
    data = diversity.fst.matrix, 
    varnames = c("POP2", "POP1"),
    value.name = "DIVERSITY",
    na.rm = TRUE)[reshape2::melt(lower.tri(diversity.fst.matrix, diag = FALSE))$value,]
) %>% 
  tibble::as_data_frame() %>% 
  dplyr::mutate_at(.cols = c("POP2", "POP1"), .funs = as.character) %>% # the pop1 and 2 inverted compared to hierfstat script
  dplyr::select(POP1, POP2, DIVERSITY) %>% 
  dplyr::arrange(POP1, POP2)
diversity.fst
```

# GENODIVE

* use the `genepop` file created above
* in `GENODIVE`: Analysis -> Pairwise Differentiation -> Fst with 1 permutations
* Save the matrix content only (no weird pop id or superflous column): genodive.sunflower.tsv
* Import the fst matrix in R, with pop.id string created earlier (`pop.list`), because population naming from genepop file sucks
* no need for a coffee, `GENODIVE` is coded in Objective-C (~ < 3 sec on my MBP)

```{r import GENODIVE results}
genodive.fst.matrix <- as.matrix(
  read.table(
    file = "genodive.sunflower.tsv", 
    col.names = pop.list, 
    row.names = pop.list
  )
)
```

`GENODIVE` results need more work to be useful:
* transform the lower matrix into a more useful pairwise df with appropriate column names

```{r GENODIVE results manipulation}
genodive.fst <- stats::na.omit(
  reshape2::melt(
    data = genodive.fst.matrix, 
    varnames = c("POP1", "POP2"),
    value.name = "GENODIVE",
    na.rm = TRUE)[reshape2::melt(upper.tri(genodive.fst.matrix, diag = FALSE))$value,]
) %>% 
  tibble::as_data_frame() %>% 
  dplyr::mutate_at(.cols = c("POP1", "POP2"), .funs = as.character) %>% 
  dplyr::arrange(POP1, POP2)
# remove unwanted object
rm(genodive.fst.matrix)
genodive.fst
```

# ASSIGNER

```{r run assigner}
# timing is included in the computation
assigner.fst.results <- assigner::fst_WC84(data = sunflower$tidy.data, pairwise = TRUE, verbose = TRUE)
```

* with ~ 152 sec it's more than 20 times faster than `hierfstat` or `strataG`!
* not as good as `GENODIVE` (~ 3sec) or `diveRsity::diffCalc` (~ 66 sec).
* but `assigner::fst_WC84` is entirely coded in R, whereas `GENODIVE` and
`diveRsity::diffCalc` are entirely or partly coded in Objective-C/C++, respectively.
* I really like `diveRsity`, but including `diveRsity::diffCalc` 
inside `assigner::assignment_ngs` include a cost not considered here:
writting genepop files thousands of time increases computational time, substantially.
* I like having the other info provided by `assigner::fst_WC84`

If you want to see the distribution of overall Fst values:
```{r show fst plot}
assigner.fst.results$fst.plot
```

Interested in the Fst overall values:
```{r show overall table}
assigner.fst.results$fst.overall
```

If you run the function with `ci = TRUE` and give higher number of iterations 
e.g. `iteration.ci = 10000` you'll get decent confidence intervals with 
global and pariwise Fst estimates.

Transfer the pairwise results in a separate df
```{r isolate pairwise df}
assigner.fst <- assigner.fst.results$pairwise.fst %>% 
  dplyr::rename(ASSIGNER = FST)
assigner.fst
```

# SUMMARY

Join all the result together in one table:

```{r join results together}
fst.summary <- dplyr::select(assigner.fst, -N_MARKERS) %>%
  dplyr::full_join(hierfstat.fst, by = c("POP1", "POP2")) %>% 
  dplyr::full_join(stratag.fst, by = c("POP1", "POP2")) %>% 
  dplyr::full_join(diversity.fst, by = c("POP1", "POP2")) %>% 
  dplyr::full_join(genodive.fst, by = c("POP1", "POP2"))
fst.summary
```

Correlation between `assigner` and `hierfstat` speaks for itself:
```{r correlation assigner - hierfstat}
stats::cor(x = fst.summary$HIERFSTAT, y = fst.summary$ASSIGNER, use = "complete.obs")
```

Correlation between `assigner` and `GENODIVE`:
```{r correlation assigner - GENODIVE}
stats::cor(x = fst.summary$GENODIVE, y = fst.summary$ASSIGNER, use = "complete.obs")
```

Notes:

* the warning: `joining character vector and factor, coercing into character vector` is normal.

* you could go and look at the 36 pairwise comparisons, but the end of the story is very simple: 
`assigner` and `hierfstat` have equal values down to a very large number of decimals.

* `diveRsity` gives Fst values very close to `assigner` and `hierfstat`.

* `strataG` usually gives downward values

* `GENODIVE` are very close to `assigner` and `hierfstat` with a small downward bias.

Let's plot the results, but first transform the data into a tidy df:

```{r summary in tidy df}
fst.summary.tidy <- fst.summary %>% 
  tidyr::unite(data = ., col = PAIRS, POP1, POP2, sep = "-") %>% 
  tidyr::gather(data = ., key = SOFTWARE, value = FST, -PAIRS) %>% 
  dplyr::mutate(SOFTWARE = factor(SOFTWARE, levels = c("ASSIGNER", "HIERFSTAT", "STRATAG", "DIVERSITY", "GENODIVE"), ordered = TRUE))
fst.summary.tidy
```

```{r plot the results}
plot.fst <- ggplot(fst.summary.tidy, aes(x = FST, y = PAIRS, colour = SOFTWARE, shape = SOFTWARE)) +
  geom_jitter(alpha = 0.8)
plot.fst
```

